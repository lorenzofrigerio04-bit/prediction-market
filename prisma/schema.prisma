// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================
// USER MODEL
// ============================================
model User {
  id            String   @id @default(cuid())
  email         String   @unique
  name          String?
  username      String?  @unique // nome pubblico modificabile (3-30 caratteri, alfanumerico + _)
  password      String? // null se login con OAuth
  image         String? // avatar URL
  emailVerified DateTime?
  
  // Crediti e Wallet
  credits       Int      @default(1000) // crediti iniziali
  totalEarned   Int      @default(0) // totale guadagnato nella storia
  totalSpent    Int      @default(0) // totale speso
  
  // Statistiche
  streak        Int      @default(0) // giorni consecutivi
  lastDailyBonus DateTime? // ultima volta che ha preso il daily bonus
  
  // Boost moltiplicatore temporaneo (Spin of the Day)
  boostMultiplier Float?   // es. 1.25
  boostExpiresAt   DateTime? // fino a quando il boost è attivo
  totalPredictions Int   @default(0)
  correctPredictions Int  @default(0)
  accuracy      Float    @default(0) // percentuale accuratezza
  
  // Ruolo (String per SQLite compatibilità)
  role          String   @default("USER") // USER, ADMIN o BOT (bot simulazione)
  
  // Onboarding: tutorial completato (non mostrare di nuovo)
  onboardingCompleted Boolean @default(false)
  
  // Relazioni
  predictions   Prediction[]
  comments      Comment[]
  commentReactions CommentReaction[]
  transactions  Transaction[]
  dailySpins   DailySpin[]
  badges        UserBadge[]
  missions      UserMission[]
  notifications Notification[]
  createdEvents Event[] @relation("EventCreator")
  eventFollows  EventFollower[]
  userSessions UserSession[]
  userProfile  UserProfile?
  
  // NextAuth relazioni
  accounts      Account[]
  sessions      Session[]
  
  // Timestamps
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  @@map("users")
}

// ============================================
// NEXTAUTH MODELS
// ============================================
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("sessions")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verification_tokens")
}

// ============================================
// EVENT MODEL
// ============================================
model Event {
  id          String   @id @default(cuid())
  title       String
  description String?
  category    String   // es. "Sport", "Politica", "Tecnologia", etc.
  
  // Date importanti
  createdAt   DateTime @default(now())
  closesAt    DateTime // quando chiude la previsione
  resolvedAt  DateTime? // quando è stato risolto
  
  // Risoluzione
  resolved    Boolean  @default(false)
  outcome     String? // "YES" o "NO"
  resolutionSourceUrl String? // URL fonte della risoluzione
  resolutionNotes     String? // note sulla risoluzione
  resolutionDisputedAt DateTime? // quando è stata contestata
  resolutionDisputedBy String? // userId che ha contestato
  
  // Stagione/torneo (opzionale)
  seasonId    String?
  season      Season?  @relation(fields: [seasonId], references: [id])
  
  // Statistiche aggregate
  yesPredictions Int   @default(0) // numero previsioni SÌ
  noPredictions  Int   @default(0) // numero previsioni NO
  /// @deprecated Use LMSR (q_yes, q_no, p_init, b) during migration period. Kept for backward compatibility.
  totalCredits   Int   @default(0) // totale crediti investiti
  /// @deprecated Use LMSR (q_yes, q_no) during migration period. Kept for backward compatibility.
  yesCredits     Int   @default(0) // crediti su SÌ
  /// @deprecated Use LMSR (q_yes, q_no) during migration period. Kept for backward compatibility.
  noCredits      Int   @default(0) // crediti su NO
  
  // Probabilità calcolata (yesCredits / totalCredits * 100)
  probability    Float  @default(50.0) // percentuale previsione SÌ
  
  // LMSR (Liquidity-Maker Logarithmic Market Scoring Rule)
  p_init  Float  @default(0.5)  // initial probability (yes)
  b       Float  @default(100)  // liquidity parameter
  q_yes   Float  @default(0)   // quantity of YES shares
  q_no    Float  @default(0)   // quantity of NO shares
  
  // Time coherence
  realWorldEventTime     DateTime? // when the real-world event occurs
  resolutionTimeExpected DateTime? // when resolution is expected
  resolutionBufferHours  Int?     // buffer hours after resolutionTimeExpected
  resolutionStatus       String   @default("PENDING") // PENDING, RESOLVED, DISPUTED, etc.
  
  // Creatore (admin)
  createdById   String
  createdBy     User   @relation("EventCreator", fields: [createdById], references: [id])
  
  // Relazioni
  predictions    Prediction[]
  comments       Comment[]
  followers      EventFollower[]
  marketMetrics  MarketMetrics[]
  
  @@index([category])
  @@index([closesAt])
  @@index([resolved])
  @@index([closesAt, resolved])
  @@index([seasonId])
  @@index([realWorldEventTime])
  @@index([resolutionStatus])
  @@map("events")
}

// ============================================
// EVENT FOLLOWER MODEL (Segui evento)
// ============================================
model EventFollower {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  eventId   String
  event     Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())
  
  @@unique([userId, eventId])
  @@index([userId])
  @@index([eventId])
  @@map("event_followers")
}

// ============================================
// SEASON MODEL (Stagioni/tornei)
// ============================================
model Season {
  id        String   @id @default(cuid())
  name      String
  startAt   DateTime
  endAt     DateTime
  createdAt DateTime @default(now())
  
  events    Event[]
  @@map("seasons")
}

// ============================================
// AUDIT LOG MODEL (Azioni admin)
// ============================================
model AuditLog {
  id         String   @id @default(cuid())
  userId     String? // null se azione di sistema
  action     String
  entityType String
  entityId   String?
  payload    Json? // dati aggiuntivi
  createdAt  DateTime @default(now())
  
  @@index([userId])
  @@index([entityType, entityId])
  @@index([createdAt])
  @@map("audit_logs")
}

// ============================================
// PREDICTION MODEL
// ============================================
model Prediction {
  id          String   @id @default(cuid())
  
  // Relazioni
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  eventId     String
  event       Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)
  
  // Previsione
  outcome     String // "YES" o "NO"
  credits     Int // quanti crediti ha investito (deprecated: kept for backward compatibility)
  
  // LMSR (Logarithmic Market Scoring Rule) fields
  sharesYes   Float? // YES shares purchased (LMSR)
  sharesNo    Float? // NO shares purchased (LMSR)
  costBasis   Float? // Cost in credits (LMSR cost function)
  
  // Risultato (null se evento non ancora risolto)
  resolved    Boolean  @default(false)
  won         Boolean? // true se ha vinto, false se ha perso
  payout      Int? // crediti guadagnati (null se non ancora risolto)
  
  // Timestamps
  createdAt   DateTime @default(now())
  resolvedAt  DateTime?
  
  @@unique([userId, eventId]) // un utente può fare una sola previsione per evento
  @@index([userId])
  @@index([eventId])
  @@index([resolved])
  @@index([userId, resolved])
  @@map("predictions")
}

// ============================================
// COMMENT MODEL
// ============================================
model Comment {
  id          String   @id @default(cuid())
  
  // Relazioni
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  eventId     String
  event       Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)
  
  // Threading (commenti annidati)
  parentId    String? // null se è un commento principale
  parent      Comment? @relation("CommentReplies", fields: [parentId], references: [id])
  replies     Comment[] @relation("CommentReplies")
  
  // Contenuto
  content     String
  
  // Moderazione
  hidden      Boolean   @default(false)
  
  // Reazioni
  reactions   CommentReaction[]
  
  // Timestamps
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@index([eventId])
  @@index([userId])
  @@index([parentId])
  @@map("comments")
}

// ============================================
// COMMENT REACTION MODEL
// ============================================
model CommentReaction {
  id        String   @id @default(cuid())
  
  // Relazioni
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  commentId String
  comment   Comment  @relation(fields: [commentId], references: [id], onDelete: Cascade)
  
  // Tipo reazione (String per SQLite)
  type      String // "THUMBS_UP", "FIRE", "HEART"
  
  createdAt DateTime @default(now())
  
  @@unique([userId, commentId, type]) // un utente può avere una sola reazione di ogni tipo per commento
  @@index([commentId])
  @@map("comment_reactions")
}

// ============================================
// DAILY SPIN MODEL (Spin of the Day)
// ============================================
model DailySpin {
  id          String   @id @default(cuid())
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Tipo reward: CREDITS | BOOST
  rewardType  String
  
  // Payload JSON: { "amount": number } per CREDITS, { "multiplier": number, "durationMinutes": number } per BOOST
  rewardPayload Json
  
  createdAt   DateTime @default(now())
  
  @@index([userId])
  @@index([userId, createdAt])
  @@map("daily_spins")
}

// ============================================
// TRANSACTION MODEL (Wallet)
// ============================================
model Transaction {
  id          String   @id @default(cuid())
  
  // Relazione
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Tipo transazione (String per SQLite)
  type        String // PREDICTION_BET, PREDICTION_WIN, etc.
  
  // Importo (positivo per guadagni, negativo per spese)
  amount      Int
  
  // Descrizione
  description String?
  
  // Riferimento opzionale (es. predictionId per vincite)
  referenceId String? // può essere predictionId, missionId, etc.
  referenceType String? // "prediction", "daily_bonus", "mission", etc.
  
  // Balance dopo questa transazione
  balanceAfter Int
  
  createdAt   DateTime @default(now())
  
  @@index([userId])
  @@index([type])
  @@index([createdAt])
  @@map("transactions")
}

// ============================================
// BADGE MODEL
// ============================================
model Badge {
  id          String   @id @default(cuid())
  name        String   @unique
  description String
  icon        String? // emoji o URL icona
  rarity      String   @default("COMMON") // COMMON, RARE, EPIC, LEGENDARY
  
  // Criteri per sbloccare (opzionale, per logica futura) - String per SQLite
  criteria    String? // JSON come stringa: es. '{"predictions": 10, "streak": 7}'
  
  createdAt   DateTime @default(now())
  
  // Relazioni
  users       UserBadge[]
  
  @@map("badges")
}

// ============================================
// USER BADGE MODEL (Junction Table)
// ============================================
model UserBadge {
  id        String   @id @default(cuid())
  
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  badgeId   String
  badge     Badge    @relation(fields: [badgeId], references: [id], onDelete: Cascade)
  
  unlockedAt DateTime @default(now())
  
  @@unique([userId, badgeId])
  @@index([userId])
  @@map("user_badges")
}

// ============================================
// MISSION MODEL
// ============================================
model Mission {
  id          String   @id @default(cuid())
  name        String
  description String
  type        String // MAKE_PREDICTIONS, WIN_PREDICTIONS, etc.
  
  // Obiettivo
  target      Int // es. "fai 3 previsioni" -> target = 3
  
  // Categoria opzionale: missione conta solo previsioni in questa categoria (es. "Tecnologia")
  category    String?
  
  // Ricompensa
  reward      Int // crediti guadagnati
  
  // Durata (String per SQLite)
  period      String   @default("DAILY") // DAILY, WEEKLY, MONTHLY, PERMANENT
  startDate   DateTime?
  endDate     DateTime?
  
  // Attiva
  active      Boolean  @default(true)
  
  createdAt   DateTime @default(now())
  
  // Relazioni
  userProgress UserMission[]
  
  @@map("missions")
}

// ============================================
// USER MISSION MODEL (Progress Tracking)
// ============================================
model UserMission {
  id          String   @id @default(cuid())
  
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  missionId   String
  mission     Mission  @relation(fields: [missionId], references: [id], onDelete: Cascade)
  
  // Progresso
  progress    Int      @default(0)
  completed   Boolean  @default(false)
  completedAt DateTime?
  
  // Periodo (per missioni giornaliere/settimanali)
  periodStart DateTime @default(now())
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@unique([userId, missionId, periodStart]) // un utente può avere una missione per periodo
  @@index([userId])
  @@index([missionId])
  @@index([completed])
  @@map("user_missions")
}

// ============================================
// NOTIFICATION MODEL
// ============================================
model Notification {
  id        String   @id @default(cuid())
  
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Tipo notifica (String per SQLite)
  type      String // EVENT_RESOLVED, PREDICTION_WON, etc.
  
  // Contenuto
  title     String
  message   String
  
  // Riferimento (es. eventId, predictionId)
  referenceId String?
  referenceType String?
  
  // Stato
  read      Boolean  @default(false)
  readAt    DateTime?
  
  createdAt DateTime @default(now())
  
  @@index([userId])
  @@index([read])
  @@index([createdAt])
  @@map("notifications")
}

// ============================================
// MARKET METRICS MODEL (Hourly market analytics)
// ============================================
model MarketMetrics {
  id          String   @id @default(cuid())
  
  // Relazione
  eventId     String
  event       Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)
  
  // Timestamp (hour bucket)
  hour        DateTime // truncated to hour
  
  // Metriche
  volume      Float    @default(0) // volume di trading nell'ora
  uniqueUsers Int      @default(0) // utenti unici che hanno fatto trading
  impressions Int      @default(0) // visualizzazioni dell'evento
  clicks      Int      @default(0) // click sull'evento
  successScore Float?  // (volumeRate*0.4) + (userRate*0.3) + (ctr*0.3)
  
  createdAt   DateTime @default(now())
  
  @@unique([eventId, hour])
  @@index([eventId])
  @@index([hour])
  @@index([eventId, hour])
  @@map("market_metrics")
}

// ============================================
// MARKET ANALYTICS RAW (Raw view/click events for aggregation)
// ============================================
model MarketAnalyticsRaw {
  id        String   @id @default(cuid())
  eventId   String
  userId    String?  // null for anonymous
  eventType String   // "impression" | "click"
  createdAt DateTime @default(now())
  
  @@index([eventId, eventType, createdAt])
  @@index([createdAt])
  @@map("market_analytics_raw")
}

// ============================================
// USER SESSION MODEL (Analytics sessioni utente)
// ============================================
model UserSession {
  id             String   @id @default(cuid())
  
  // Relazione
  userId         String
  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Timestamps sessione
  startedAt      DateTime @default(now())
  endedAt        DateTime?
  
  // Metriche sessione
  durationSeconds Int?    // durata in secondi (calcolata se endedAt presente)
  pageViews      Int      @default(0) // numero di pagine visitate
  actions        Int      @default(0) // numero di azioni (click, previsioni, etc.)
  
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  
  @@index([userId])
  @@index([startedAt])
  @@index([endedAt])
  @@map("user_sessions")
}

// ============================================
// USER PROFILE MODEL (Profilo utente esteso)
// ============================================
model UserProfile {
  id                String   @id @default(cuid())
  
  // Relazione 1:1 con User
  userId            String   @unique
  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Preferenze
  preferredCategories Json?  // array di categorie preferite: ["Sport", "Tecnologia", ...]
  riskTolerance     String?  // LOW, MEDIUM, HIGH
  preferredHorizon  String?  // SHORT (giorni), MEDIUM (settimane), LONG (mesi)
  noveltySeeking   Float?   // 0.0 - 1.0, quanto cerca novità
  
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  
  @@index([userId])
  @@map("user_profiles")
}
